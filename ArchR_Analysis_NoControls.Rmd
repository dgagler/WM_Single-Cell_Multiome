---
title: "WM_ArchR_Analysis"
output: html_document
date: "2023-06-27"
---

```{r}
setwd("/Users/gagled01/morganLab/Waldenstroms/singlecell/data/ATAC_3")
fragments <- list.files(getwd())
fragments <- fragments[1:7] # only take WM fragments
```

```{r}
library(ArchR)
library(Seurat)
addArchRThreads(threads = 1)
addArchRGenome("hg38")
```

```{r}
arrow.files <- createArrowFiles(
  inputFiles = fragments,
  sampleNames = as.character(fragments),
  minTSS = 4,
  minFrags = 1000,
  addTileMat = T,
  addGeneScoreMat = T
)

arrow.files <- c("/Users/gagled01/morganLab/Waldenstroms/singlecell/data/ATAC_3/WM_FullSet_Rerun_WARNING_PlotRepoHere/ArrowFiles/01-076_atac_fragments.tsv.gz.arrow",
                 "/Users/gagled01/morganLab/Waldenstroms/singlecell/data/ATAC_3/WM_FullSet_Rerun_WARNING_PlotRepoHere/ArrowFiles/01-115_atac_fragments.tsv.gz.arrow",
                 "/Users/gagled01/morganLab/Waldenstroms/singlecell/data/ATAC_3/WM_FullSet_Rerun_WARNING_PlotRepoHere/ArrowFiles/01-131_atac_fragments.tsv.gz.arrow",
                 "/Users/gagled01/morganLab/Waldenstroms/singlecell/data/ATAC_3/WM_FullSet_Rerun_WARNING_PlotRepoHere/ArrowFiles/01-163_atac_fragments.tsv.gz.arrow",
                 "/Users/gagled01/morganLab/Waldenstroms/singlecell/data/ATAC_3/WM_FullSet_Rerun_WARNING_PlotRepoHere/ArrowFiles/01-190_atac_fragments.tsv.gz.arrow",
                 "/Users/gagled01/morganLab/Waldenstroms/singlecell/data/ATAC_3/WM_FullSet_Rerun_WARNING_PlotRepoHere/ArrowFiles/04-003_atac_fragments.tsv.gz.arrow",
                 "/Users/gagled01/morganLab/Waldenstroms/singlecell/data/ATAC_3/WM_FullSet_Rerun_WARNING_PlotRepoHere/ArrowFiles/04-006_atac_fragments.tsv.gz.arrow")
```
# Doublet inference
# Doublets are inevitable in single cell data. The % of doublets is proportional to the number of cells loaded into the experiment. 
# Doublets are especially problematic in the context of developmental/trajectory data because doublets can look like a mixture between 2 cell types which can be confounded with intermediate cell states. THIS WM DATA IS B CELL LINEAGE...SO TRAJECTORY!!! 
# To predict doublets, ArchR mixes the reads from large combos of cells to create synthetic doublets and projects them into a UMAP. Iterating this process 1000x times allows identification of cells in the REAL data which look like synthetic doublets.
# We want to see R values greater than 0.9, which implies that the cells within each synthetic UMAP have significant heterogeneity, which we want.
# In the output plots, use the doublet enrichment plot 
```{r}
dub.scores <- addDoubletScores(
  input = arrow.files,
  k = 10,
  knnMethod = "UMAP",
  LSIMethod = 1,
  force = T
) 
```
########################################################
###### CHAPTER 3 - Create ArchRProject and QC ##########
########################################################

Load existing ArchR project
```{r}
archR <- loadArchRProject(path = "/Users/gagled01/morganLab/Waldenstroms/singlecell/data/ATAC_3/WM_noControls_FullIntegration_UpdatedMetadata_PC-MBC_ONLY")
```

```{r}
archR <- ArchRProject(
  ArrowFiles = arrow.files,
  outputDirectory = "WM_FullSetRetrun_NoControls",
  copyArrows = T
)
```
# Clean up sample names
```{r}
# Iteratively clean up sample names
clean.samplenames <- gsub("_atac_fragments.tsv.gz", "", archR$Sample)
archR$samplesClean <- clean.samplenames
clean.samplenames2 <- gsub("_fragments.tsv.bgz", "", archR$samplesClean)
archR$samplesClean <- clean.samplenames2
clean.samplenames3 <- gsub("_fragments.tsv.gz", "", archR$samplesClean)
archR$samplesClean <- clean.samplenames3

table(archR$samplesClean)

archR$batch <- "2"
archR$batch[archR$samplesClean %in% c("01-190", "04-003")] <- "1"
table(archR$batch)
```
Add TRUST4 metadata
```{r}
cell_id_fixed <- gsub("0.-..._", "", archR$cellNames_clean)
archR$cell_id_fixed <- cell_id_fixed
cell_id_fixed2 <- gsub("-1", "", archR$cell_id_fixed)
archR$cell_id_fixed <- cell_id_fixed2

# Load barcode files
p01_076_barcodes <- read.table("/Users/gagled01/morganLab/Waldenstroms/TRUST4_working/outputs/barcode_reports/TRUST_01-076_gex_possorted_bam_barcode_airr.tsv", sep = "\t", header = T)
p01_115_barcodes <- read.table("/Users/gagled01/morganLab/Waldenstroms/TRUST4_working/outputs/barcode_reports/TRUST_01-115_gex_possorted_bam_barcode_airr.tsv", sep = "\t", header = T)
p01_131_barcodes <- read.table("/Users/gagled01/morganLab/Waldenstroms/TRUST4_working/outputs/barcode_reports/TRUST_01-131_gex_possorted_bam_barcode_airr.tsv", sep = "\t", header = T)
p01_163_barcodes <- read.table("/Users/gagled01/morganLab/Waldenstroms/TRUST4_working/outputs/barcode_reports/TRUST_01-163_gex_possorted_bam_barcode_airr.tsv", sep = "\t", header = T)
p01_190_barcodes <- read.table("/Users/gagled01/morganLab/Waldenstroms/TRUST4_working/outputs/barcode_reports/TRUST_01-190_gex_possorted_bam_barcode_airr.tsv", sep = "\t", header = T)
p04_003_barcodes <- read.table("/Users/gagled01/morganLab/Waldenstroms/TRUST4_working/outputs/barcode_reports/TRUST_04-003_gex_possorted_bam_barcode_airr.tsv", sep = "\t", header = T)
p04_006_barcodes <- read.table("/Users/gagled01/morganLab/Waldenstroms/TRUST4_working/outputs/barcode_reports/TRUST_04-006_gex_possorted_bam_barcode_airr.tsv", sep = "\t", header = T)

# Fix cell ids
p01_076_barcodes$cell_id_fixed <- gsub("-1", "", p01_076_barcodes$cell_id)
p01_115_barcodes$cell_id_fixed <- gsub("-1", "", p01_115_barcodes$cell_id)
p01_131_barcodes$cell_id_fixed <- gsub("-1", "", p01_131_barcodes$cell_id)
p01_163_barcodes$cell_id_fixed <- gsub("-1", "", p01_163_barcodes$cell_id)
p01_190_barcodes$cell_id_fixed <- gsub("-1", "", p01_190_barcodes$cell_id)
p04_003_barcodes$cell_id_fixed <- gsub("-1", "", p04_003_barcodes$cell_id)
p04_006_barcodes$cell_id_fixed <- gsub("-1", "", p04_006_barcodes$cell_id)

# Merge into single df
all_barcodes <- rbind(p01_076_barcodes, p01_115_barcodes, p01_131_barcodes, p01_163_barcodes, p04_006_barcodes)
dim(all_barcodes)

# Update metadata
archR$v_call <- all_barcodes$v_call[match(archR$cell_id_fixed, all_barcodes$cell_id_fixed)]
archR$d_call <- all_barcodes$d_call[match(archR$cell_id_fixed, all_barcodes$cell_id_fixed)]
archR$j_call <- all_barcodes$j_call[match(archR$cell_id_fixed, all_barcodes$cell_id_fixed)]
archR$c_call <- all_barcodes$j_call[match(archR$cell_id_fixed, all_barcodes$cell_id_fixed)]
archR$cdr1 <- all_barcodes$cdr1[match(archR$cell_id_fixed, all_barcodes$cell_id_fixed)]
archR$cdr2 <- all_barcodes$cdr2[match(archR$cell_id_fixed, all_barcodes$cell_id_fixed)]
archR$complete_vdj <- all_barcodes$complete_vdj[match(archR$cell_id_fixed, all_barcodes$cell_id_fixed)]
archR$consensus_count <- all_barcodes$consensus_count[match(archR$cell_id_fixed, all_barcodes$cell_id_fixed)]

length(table(archR$v_call))

p1 <- plotEmbedding(ArchRProj = archR, colorBy = "cellColData", name = "v_call", embedding = "NoControls_Reclustered_UMAP") + NoLegend()
p1
```

# They have found that the best metrics for QC are the TSS enrichment score and the number of unique frags
# Note that in creating the arrow files we have already set minimum values for both the TSS (n = 4) and n frags (n = 1000)
# But let's still plot it up to see what remains
```{r}
qc.df <- getCellColData(archR, select = c("log10(nFrags)", "TSSEnrichment"))

p <- ggPoint(
  x = qc.df[,1],
  y = qc.df[,2],
  colorDensity = T,
  continuousSet = "sambaNight",
  xlabel = "Log10 Unique Fragments",
  ylabel = "TSS Enrichment",
  xlim = c(log10(500), quantile(qc.df[,1], probs = 0.99)),
  ylim = c(0, quantile(qc.df[,2], probs = 0.99))
) + geom_hline(yintercept = 4, lyt = "dashed") + geom_vline(xintercept = 3, lyt = "dashed")

p

plotPDF(p, name = "TSS-vs-Frags.pdf", ArchRProj = archR, addDOC = F) # save it out
```
# Make ridge and violin plots of TSS enrichment
```{r}
ridge <- plotGroups(
  ArchRProj = archR,
  groupBy = "samplesClean",
  colorBy = "cellColData",
  name = "TSSEnrichment",
  plotAs = "ridges"
)

violin <- plotGroups(
  ArchRProj = archR,
  groupBy = "samplesClean",
  colorBy = "cellColData",
  name = "TSSEnrichment",
  alpha = 0.4,
  plotAs = "violin"
)

ridge
violin
plotPDF(ridge, violin, name = "TSS_Ridge_Violin.pdf", ArchRProj = archR, addDOC = F, width = 5, height = 5)

```
# Make ridge plot of unique frags
```{r}
p3 <- plotGroups(
    ArchRProj = archR, 
    groupBy = "samplesClean", 
    colorBy = "cellColData", 
    name = "log10(nFrags)",
    plotAs = "ridges"
   )

plotPDF(p3, name = "QC-Sample-FragSizes-Ridges.pdf", ArchRProj = archR, addDOC = F, width = 5, height = 5)
```
# Plot fragment size distribution and TSS enrichment by sample
# The TSS enrichment plot should show a clear peak in the center and a small peak to eh right caused by the well-positioned +1 nucleosome
```{r}
p1 <- plotFragmentSizes(ArchRProj = archR)

p2 <- plotTSSEnrichment(ArchRProj = archR)

p1
p2

plotPDF(p1, p2, name = "QC-Sample-FragSizes-TSSProfile.pdf", ArchRProj = archR, addDOC = F, width = 5, height = 5)
```
# Subsetting out cells with low TSS in samples 01-190 and 04-003
```{r}
idsRemove <- as.character(archR$cellNames[(archR$samplesClean %in% c("01-190", "04-003") & archR$TSSEnrichment < 8)])
archR <- archR[!archR$cellNames %in% idsRemove,]

ridge2 <- plotGroups(
  ArchRProj = archR,
  groupBy = "samplesClean",
  colorBy = "cellColData",
  name = "TSSEnrichment",
  plotAs = "ridges"
)

plotPDF(ridge2, name = "TSS_Ridge_Violin_BelowTSS9_Removed.pdf", ArchRProj = archR, addDOC = F, width = 5, height = 5)

ridge2
```

# Default ratio is 1
```{r}
archR <- filterDoublets(archR, filterRatio = 1)
```
# Save project out
# This copies a new set of arrow files and a new ArchRProj to the output dir
# Unless you specify load = F, this existing project in this R studio will still be the ORIGINAL arrow files
```{r}
saveArchRProject(ArchRProj = archR, outputDirectory = "WM5_FullSet", load = T)
```
# Filtering doublets
# This filters based on a ratio which allows you to apply a consistent filter across different samples with different % of doublets

############################################
### CHAPTER 4 - DIMENSIONALITY REDUCTION ###
############################################

# Dimensionality reduction with scATAC-seq data is tough due to data sparsity. A particular site is either accessible on one allele, both, or neither.
# It ends up that many loci have 0 accessible alleles. As such, you'd be reluctant to say that a cell with 3 insertions in a given site is actually 3x more accessible than another cell with only 1 insertion in the same site. 
# Many analytical strategies then binarizes their ATAC data matrix to 1s and 0s, which is mostly 0s. But this is still difficult because 0 can mean both non-accessible and not-sampled and these are different things biologically.
# If you would perform a standard dimensionality reduction like PCA, the first PC would just be all of the 0 positions
# This is gotten around via a layered dimensionality reduction approach
# First, we use a Latent Semantic Indexing (LSI) which is borrowed from natural language processing
# This calculates the peak frequency per cell, normalized by depth.
# These values are then normalized by the inverse document frequency which weighs features by how often they occur, identifying features that are more specific rather than commonly accessible
# The resultant term frequency-inverse document frequency (TF-IDF) matrix reflects how important a region/peak is to a sample.
# Then, through a technique called singular value decomposition (SVD), the most valuable information across samples is identified and represented in a lower dimensional space. Dam
# Finally, a more conventional dimensionality reduction technique like UMAP can be used to visualize the data

# ArchR offers a few different LSI implementations but by default uses the method introduced in Signac (!), which uses a term frequency that has been depth normalized to 10,000 and again normalized with the log(tf-idf)
# It is suggested to use genome-wide tiles as the inputs to LSI dimensionality reduction, but these can become prohibitively large. ArchR can do this more rapidly using 500bp tiles...but also offers an "estimated LSI" approach which only uses a subset of total cells, thereby speeding up the process and decreasing granularity of the data, which may end up reducing batch effects in the data

#### Iterative Latent Semantic Indexing (LSI) ####
# This approach computes an initial LSI transformation on the most accessible tiles and then another on the top variable features from the first iteration. You can repeat this more if necessary
# LSI is NOT deterministic...so you will not get exactly the same results. So make sure to save the ArchRProject once you have an ideal dimensionality reduction
```{r}
archR <- addIterativeLSI(
  ArchRProj = archR,
  useMatrix = "TileMatrix",
  name = "IterativeLSI",
  iterations = 2,
  clusterParams = list( # based on Seurat's FindClusters()
    resolution = c(0.25),
    sampleCells = 10000,
    n.start = 10
  ),
  varFeatures = 25000,
  dimsToUse = 1:30,
  force = T
)
```
# You can also explicitly correct for batch effect with Harmony
# See documentation for this. Won't do now because only 1 sample lol
####################################
### BATCH CORRECTION VIA HARMONY ###
####################################
```{r}
archR <- addHarmony(
    ArchRProj = archR,
    reducedDims = "IterativeLSI",
    name = "Harmony_Batch",
    groupBy = "batch",
    force = T
)

archR <- addHarmony(
    ArchRProj = archR,
    reducedDims = "IterativeLSI",
    name = "Harmony_Samples",
    groupBy = "samplesClean",
    force = T
)
```
##############################
### CHAPTER 5 - CLUSTERING ###
##############################

# ArchR basically just uses Seurat's FindClusters()
```{r}
archR <- addClusters(
  input = archR,
  reducedDims = "IterativeLSI",
  method = "Seurat",
  name = "Clusters",
  resolution = 0.8,
  force = TRUE
)

archR <- addClusters(
  input = archR,
  reducedDims = "Harmony_Batch",
  method = "Seurat",
  name = "HarmonyClusters",
  resolution = 1,
  force = TRUE
)
```
#####################################
### CHAPTER 6 - EMBEDDINGS (UMAP) ###
#####################################

```{r}
archR <- addUMAP(
  ArchRProj = archR,
  reducedDims = "IterativeLSI",
  name = "UMAP",
  nNeighbors = 30,
  minDist = 0.5,
  metric = "cosine",
  force = T
)

archR <- addUMAP(
    ArchRProj = archR, 
    reducedDims = "Harmony_Batch", 
    name = "UMAPHarmony", 
    nNeighbors = 30, 
    minDist = 0.5, 
    metric = "cosine",
    force = T
)

p1 <- plotEmbedding(ArchRProj = archR, colorBy = "cellColData", name = "samplesClean", embedding = "UMAP") #+ 
p2 <- plotEmbedding(ArchRProj = archR, colorBy = "cellColData", name = "samplesClean", embedding = "UMAPHarmony_Batch")
plotPDF(p1, p2, p3, name = "Cleaned_Plot-UMAP-Clusters_BatchCorrectionComparison.pdf", ArchRProj = archR, addDOC = FALSE, width = 5, height = 5)
```
# Comparing clusterings
```{r}
p1 <- plotEmbedding(ArchRProj = archR, colorBy = "cellColData", name = "samplesClean", embedding = "UMAPHarmony") #+ 
p2 <- plotEmbedding(ArchRProj = archR, colorBy = "cellColData", name = "HarmonyClusters", embedding = "UMAPHarmony")

plotPDF(p1, p2, name = "Cleaned_Plot-UMAP-Harmony_PatientsClusters.pdf", ArchRProj = archR, addDOC = FALSE, width = 5, height = 5)
```
# UMAPs highlighted by patient
```{r}
p01_076_cells <- archR$cellNames[archR$samplesClean == "01-076"]
p01_115_cells <- archR$cellNames[archR$samplesClean == "01-115"]
p01_131_cells <- archR$cellNames[archR$samplesClean == "01-131"]
p01_163_cells <- archR$cellNames[archR$samplesClean == "01-163"]
p01_190_cells <- archR$cellNames[archR$samplesClean == "01-190"]
p04_003_cells <- archR$cellNames[archR$samplesClean == "04-003"]
p04_006_cells <- archR$cellNames[archR$samplesClean == "04-006"]


p1 <- plotEmbedding(ArchRProj = archR, colorBy = "cellColData", name = "samplesClean", embedding = "UMAPHarmony", highlightCells = p01_076_cells)
p2 <- plotEmbedding(ArchRProj = archR, colorBy = "cellColData", name = "samplesClean", embedding = "UMAPHarmony", highlightCells = p01_115_cells)
p3 <- plotEmbedding(ArchRProj = archR, colorBy = "cellColData", name = "samplesClean", embedding = "UMAPHarmony", highlightCells = p01_131_cells)
p4 <- plotEmbedding(ArchRProj = archR, colorBy = "cellColData", name = "samplesClean", embedding = "UMAPHarmony", highlightCells = p01_163_cells)
p5 <- plotEmbedding(ArchRProj = archR, colorBy = "cellColData", name = "samplesClean", embedding = "UMAPHarmony", highlightCells = p01_190_cells)
p6 <- plotEmbedding(ArchRProj = archR, colorBy = "cellColData", name = "samplesClean", embedding = "UMAPHarmony", highlightCells = p04_003_cells)
p7 <- plotEmbedding(ArchRProj = archR, colorBy = "cellColData", name = "samplesClean", embedding = "UMAPHarmony", highlightCells = p04_006_cells)

plotPDF(p1,p2,p3,p4,p5,p6,p7, name = "Cleaned_Plot-UMAP-by-Patient.pdf", ArchRProj = archR, addDOC = FALSE, width = 5, height = 5)

```
################################################
### CHAPTER 7 - GENE SCORES AND MARKER GENES ###
################################################

# Seems like ATAC annotation is basically manual...
# Estimate gene expression based on chromatin accessibility data using gene scores
# The default gene score model in ArchR which considers the accessibility of the entire gene (not just part?), accounts for the activity of putative distal regulatory elements,  
# and considers imposed gene boundaries which minimize the contributed of unrelated regulatory elements. So it tries to emphasize the right distal elements and minimize the wrong

# GENE SCORE - PREDICTION OF GENE EXPRESSION BASED ON ACCESSIBLIITY! 
# BUT WE HAVE ACTUAL EXPRESSION DATA!!! HOW TO CONNECT?

# Does this by creating a tile matrix (default 500bp), overlapping the tiles by some window (default 100kb on either side of the gene?), and computes distance from tile to the gene body. Best predictor of gene expression is local accessibility of the gene region which includes both the promoter and gene body. To identify distal promoters, they subset out tiles that are within the gene window (so 100kb on either side) but do not cross another gene region. They also weigh smaller genes more because large genes can otherwise bias gene scores. So the distance from each tile to the nearby gene is converted to a weight, that weight is again weighted by inverse of gene size. These weights are then multiplied by the number of Tn5 insertions within each tile and summed across all tiles within the gene window. This is the gene score. The gene score is then depth normalized across all genes (default 10000). Dam what the hell lmao.

# Identification of marker features per cluster (this can include peaks, genes, or transcription factor motifs). Can use any matrix as input, including TileMatrix and PeakMatrix, at least. I wonder if GEX?
# Going to skip technical details for now...
```{r}
gs.markers <- getMarkerFeatures(
  ArchRProj = archR,
  useMatrix = "GeneScoreMatrix",
  groupBy = "HarmonyClusters",
  bias = c("TSSEnrichment", "log10(nFrags)"), # normalizing based on these metrics?
  testMethod = "wilcoxon"
)

markerList <- getMarkers(gs.markers, cutOff = "FDR <= 0.01 & Log2FC >= 1.25")
head(markerList$C5, n = 10)
```
# Visualize via heatmap
```{r}
#marker.genes <- c("PAX5", "MS4A1", "EBF1", "BCL6", "MME", "CD79A", "CR2", "CD27", "CD74", "HLA-DRA", "RACK1", "IGKC", "JCHAIN", "MZB1", "XBP1")
markerGenes <- c("PAX5", "MS4A1", "MUM1", "CD27", "BCL6", "SDC1", "CD38", "CD24", "CD19")

heatmapGS <- plotMarkerHeatmap(
  seMarker = gs.markers,
  cutOff = "FDR <= 0.01 & Log2FC >= 1.25",
  labelMarkers = markerGenes,
  transpose = T
)

ComplexHeatmap::draw(heatmapGS, heatmap_legend_side = "bot", annotation_legend_side = "bot")

plotPDF(heatmapGS, name = "GeneScores-Marker-Heatmap", width = 8, height = 6, ArchRProj = archR, addDOC = FALSE)
```
# Marker gene inputation with MAGIC to improve UMAPs
```{r}
archR <- addImputeWeights(archR)

markerGenes <- c("PAX5", "MS4A1", "MUM1", "CD27", "BCL6", "SDC1", "CD38", "CD24", "CD19")

p <- plotEmbedding(
    ArchRProj = archR, 
    colorBy = "GeneScoreMatrix", 
    name = markerGenes, 
    embedding = "UMAP",
    imputeWeights = getImputeWeights(archR)
)

p$PAX5
p$BCL6
p$MUM1
p$MS4A1 # MS4A1 = CD20
p$CD27
p$SDC1 # SDC1 = CD138
p$CD38

p2 <- lapply(p, function(x){
    x + guides(color = FALSE, fill = FALSE) + 
    theme_ArchR(baseSize = 6.5) +
    theme(plot.margin = unit(c(0, 0, 0, 0), "cm")) +
    theme(
        axis.text.x=element_blank(), 
        axis.ticks.x=element_blank(), 
        axis.text.y=element_blank(), 
        axis.ticks.y=element_blank()
    )
})
do.call(cowplot::plot_grid, c(list(ncol = 2),p))

p2
plotPDF(plotList = p2, 
    name = "Plot-UMAP-Marker-Genes-W-Imputation.pdf", 
    ArchRProj = archR, 
    addDOC = FALSE, width = 5, height = 5)
```
Saving out again
```{r}
saveArchRProject(ArchRProj = archR, outputDirectory = "FullSetRerun_NoControls", load = FALSE)
```

######################## KEY FIGURE ALERT!!!? ###########################
### Plotting Tracks of local chromatin accessibilty for marker genes ###
########################################################################
```{r}
p <- plotBrowserTrack(
    ArchRProj = archR, 
    groupBy = "Clusters", 
    geneSymbol = markerGenes, 
    upstream = 50000,
    downstream = 50000
)

plotPDF(plotList = p, 
    name = "Plot-Tracks-Marker-Genes.pdf", 
    ArchRProj = archR, 
    addDOC = FALSE, width = 5, height = 5)
```
##########################################
### CHAPTER 8 - ALIGNING TO SCRNA DATA ###
##########################################

Aligns ATAC gene score matrix to scRNA GEX matrix. Basically just finds the scRNA cell that looks most similar to each scATAC cell.
ArchR accepts Seurat objects
# Load in Seurat object
```{r}
seurat <- readRDS("/Users/gagled01/morganLab/Waldenstroms/singlecell/objects/WM_Prelim_RNAonly_CellTypistAnnotated_AllMetadata.rds")
FeaturePlot(seurat, features = "ELF5")
VlnPlot(seurat, features = "ELF5", group.by = "majority_voting")
```
# This is an Unconstrained Integration method
```{r}
archR <- addGeneIntegrationMatrix(
  ArchRProj = archR,
  useMatrix = "GeneScoreMatrix",
  matrixName = "GeneIntegrationMatrix",
  reducedDims = "Harmony_Batch",
  seRNA = seurat,
  addToArrow = FALSE,
  groupRNA = "majority_voting",
  nameCell = "predictedCell_Un",
  nameGroup = "predictedGroup_Un",
  nameScore = "predictedScore_Un"
)

pal <- paletteDiscrete(values = seurat@meta.data$majority_voting)

p1 <- plotEmbedding(
    archR, 
    colorBy = "cellColData", 
    name = "predictedGroup_Un", 
    pal = pal
)

plotPDF(p1, name = "Cleaned_Plot-UMAP-Clusters_CellTypistAnnotated_Integrated_UMAP.pdf", ArchRProj = archR, addDOC = FALSE, width = 5, height = 5)
```
# And this is the constrained integration method, which depends on the output of the unconstrained. In our case, I don't think we need this...but we can pretend we're only interested in Plasma cells and memory B cells. and Naive, for good measure.

#####################################################
### HAVEN'T GOTTEN CONSTRAINED METHOD TO WORK YET ###
############ LETTING IT SIT FOR A SEC ###############
#####################################################

```{r}
cM <- as.matrix(confusionMatrix(archR$HarmonyClusters, archR$predictedGroup_Un))
preClust <- colnames(cM)[apply(cM, 1 , which.max)]
cbind(preClust, rownames(cM)) #Assignments

unique(unique(archR$predictedGroup_Un))

# selecting clusters that were assigned memory B or PC
cTNK <- paste0(c("Memory B cells", "Plasma cells"), collapse="|")

# and the rest
cNonTNK <- paste0(c("Classical monocytes", "Large pre-B cells", "Naive B cells", "Pro-B cells", "Small pre-B cells"), collapse="|")
cNonTNK

#Assign scATAC to these categories
clustTNK <- rownames(cM)[grep(cTNK, preClust)]
clustTNK

clustNonTNK <- rownames(cM)[grep(cNonTNK, preClust)]
clustNonTNK

# get cells in these categories
rnaTNK <- colnames(seurat)[grep(cTNK, seurat@meta.data$majority_voting)]

rnaNonTNK <- colnames(seurat)[grep(cNonTNK, seurat@meta.data$majority_voting)]

groupList <- SimpleList(
    TNK = SimpleList(
        ATAC = archR$cellNames[archR$HarmonyClusters %in% clustTNK],
        RNA = rnaTNK
    ),
    NonTNK = SimpleList(
        ATAC = archR$cellNames[archR$HarmonyClusters %in% clustNonTNK],
        RNA = rnaNonTNK
    )    
)

#~5 minutes
archR <- addGeneIntegrationMatrix(
    ArchRProj = archR, 
    useMatrix = "GeneScoreMatrix",
    matrixName = "GeneIntegrationMatrix",
    reducedDims = "Harmony_Batch",
    seRNA = seurat,
    addToArrow = TRUE, 
    groupList = groupList,
    groupRNA = "majority_voting",
    nameCell = "predictedCell_Co",
    nameGroup = "predictedGroup_Co",
    nameScore = "predictedScore_Co",
    force = TRUE
)


p1 <- plotEmbedding(
    archR, 
    colorBy = "cellColData", 
    name = "predictedGroup_Co",
    embedding = "UMAPHarmony"
)
p1
plotPDF(p1, name = "Cleaned_Plot-UMAP-Clusters_CellTypistAnnotated_ConstrainedIntegrated_UMAP.pdf", ArchRProj = archR, addDOC = FALSE, width = 5, height = 5)
```
# Adding pseudo-scRNA profiles for each scATAC cell aka Doing the Actual Integration
# Not using groupList parameter bcuz no constrained integration. Make sure nameCell, nameGroup, etc. have unconstrained values
```{r}
#~20 for 5 samples
archR <- addGeneIntegrationMatrix(
    ArchRProj = archR, 
    useMatrix = "GeneScoreMatrix",
    matrixName = "GeneIntegrationMatrix",
    reducedDims = "Harmony_Samples",
    seRNA = seurat,
    addToArrow = TRUE,
    force = TRUE,
    #groupList = groupList,
    groupRNA = "majority_voting",
    nameCell = "predictedCell_un",
    nameGroup = "predictedGroup_un",
    nameScore = "predictedScore_un"
)
```
# Plotting UMAPs overlayed with the  gene expression values from our integrated matrix
```{r}
#archR <- addImputeWeights(archR)

markerGenes <- c("PAX5", "MS4A1", "CD27", "BCL6", "SDC1", "CD38", "CD24", "CD19", "ELF5")

p1 <- plotEmbedding(
    ArchRProj = archR, 
    colorBy = "GeneIntegrationMatrix", 
    name = markerGenes, 
    continuousSet = "horizonExtra",
    embedding = "UMAPHarmony",
    imputeWeights = getImputeWeights(archR)
)

#Same plots but overlain with gene scores
p2 <- plotEmbedding(
    ArchRProj = archR,
    colorBy = "GeneScoreMatrix",
    continuousSet = "horizonExtra",
    name = markerGenes,
    embedding = "UMAPHarmony",
    imputeWeights = getImputeWeights(archR)
)
p2

plotPDF(plotList = p1, 
    name = "Plot-UMAP-Marker-Genes-RNA-W-ImputedGeneScore.pdf", 
    ArchRProj = archR, 
    addDOC = FALSE, width = 5, height = 5)

plotPDF(plotList = p2,
    name = "Plot-UMAP-Marker-Genes-Integrated_GEX.pdf",
    ArchRProj = archR,
    addDOC = FALSE, width = 5, height = 5)
```
# Labeling scATAC clusters with scRNA info
```{r}
archR$HarmonyClusters2 <- archR$predictedGroup_Co
```
# Subsetting out pre/pro B cells
```{r}
idxSample <- BiocGenerics::which(archR$HarmonyClusters2 %in% c("Plasma cells", "Memory B cells", "Naive B cells", "Small pre-B cells", "Large pre-B cells", "Pro-B cells"))
cellsSample <- archR$cellNames[idxSample]
archR_subbed <- archR[cellsSample,]

# Readding imputed weights since they got dropped when we subset
archR_subbed <- addImputeWeights(archR_subbed)
table(archR_subbed$HarmonyClusters2)
table(archR$HarmonyClusters2)
```
```{r}
patient_split <- SplitObject(archR, split.by = "patient")
p1 <- patient_split[[1]]
p2 <- patient_split[[2]]
p3 <- patient_split[[3]]
p4 <- patient_split[[4]]
p5 <- patient_split[[5]]
p6 <- patient_split[[6]]
p7 <- patient_split[[7]]

# Cell counts by patient
table(p1@meta.data$majority_voting)
table(p2@meta.data$majority_voting)
table(p3@meta.data$majority_voting)
table(p4@meta.data$majority_voting)
table(p5@meta.data$majority_voting)
table(p6@meta.data$majority_voting)
table(p7@meta.data$majority_voting)

# Relative abundance by patient
p1_relabun <- data.frame(table(p1@meta.data$majority_voting)/sum(table(p1@meta.data$majority_voting)) * 100)
p2_relabun <- data.frame(table(p2@meta.data$majority_voting)/sum(table(p2@meta.data$majority_voting)) * 100)
p3_relabun <- data.frame(table(p3@meta.data$majority_voting)/sum(table(p3@meta.data$majority_voting)) * 100)
p4_relabun <- data.frame(table(p4@meta.data$majority_voting)/sum(table(p4@meta.data$majority_voting)) * 100)
p5_relabun <- data.frame(table(p5@meta.data$majority_voting)/sum(table(p5@meta.data$majority_voting)) * 100)
p6_relabun <- data.frame(table(p6@meta.data$majority_voting)/sum(table(p6@meta.data$majority_voting)) * 100)
p7_relabun <- data.frame(table(p7@meta.data$majority_voting)/sum(table(p7@meta.data$majority_voting)) * 100)

# Absolute abundance by patient
p1_relabun$abs <- as.numeric(table(p1@meta.data$majority_voting))
p2_relabun$abs <- as.numeric(table(p2@meta.data$majority_voting))
p3_relabun$abs <- as.numeric(table(p3@meta.data$majority_voting))
p4_relabun$abs <- as.numeric(table(p4@meta.data$majority_voting))
p5_relabun$abs <- as.numeric(table(p5@meta.data$majority_voting))
p6_relabun$abs <- as.numeric(table(p6@meta.data$majority_voting))
p7_relabun$abs <- as.numeric(table(p7@meta.data$majority_voting))

p1_relabun$patient <- "01_190"
p2_relabun$patient <- "04_003"
p3_relabun$patient <- "01_131"
p4_relabun$patient <- "01_076"
p5_relabun$patient <- "01_115"
p6_relabun$patient <- "01_163"
p7_relabun$patient <- "04_006"

# bind by rows
allpatient_df <- rbind(p1_relabun, p2_relabun, p3_relabun, p4_relabun, p5_relabun, p6_relabun, p7_relabun)
colnames(allpatient_df) <- c("celltype", "relative", "patient", "absolute")

p2@meta.data$patient[1]
p3@meta.data$patient[1]
p4@meta.data$patient[1]
p5@meta.data$patient[1]
p6@meta.data$patient[1]
p7@meta.data$patient[1]
```

# Save out object
```{r}
saveArchRProject(ArchRProj = archR_subbed, outputDirectory = "WM_FullSetRerun_NoControls_Integrated_MonoRemoved", load = F)
archR <- archR_subbed
```
# Redoing UMAPs of Gene Score and Integrated GEX with subset data
```{r}
pal <- c("Memory B cells" = "forestgreen",
            "Plasma cells" = "darkorange",
            "Naive B cells" = "darkorchid3",
            "Pro-B cells" = "gold",
            "Small pre-B cells" = "lightblue",
            "Large pre-B cells" = "darkblue")

p1 <- plotEmbedding(
    archR, 
    colorBy = "cellColData",
    pal = pal,
    name = "HarmonyClusters2",
    embedding = "UMAPHarmony"
)
p1
plotPDF(p1, name = "Cleaned_Plot-UMAP-Clusters_CellTypistAnnotated_ConstrainedIntegrated_UMAP_MonoRemoved.pdf", ArchRProj = archR, addDOC = FALSE, width = 5, height = 5)

markerGenes <- c("PAX5", "MS4A1", "CD27", "BCL6", "SDC1", "CD38", "CD24", "CD19")

p1 <- plotEmbedding(
    ArchRProj = archR, 
    colorBy = "GeneIntegrationMatrix", 
    name = markerGenes, 
    continuousSet = "horizonExtra",
    embedding = "UMAPHarmony",
    imputeWeights = getImputeWeights(archR)
)

#Same plots but overlain with gene scores
p2 <- plotEmbedding(
    ArchRProj = archR,
    colorBy = "GeneScoreMatrix",
    continuousSet = "horizonExtra",
    name = markerGenes,
    embedding = "UMAPHarmony",
    imputeWeights = getImputeWeights(archR)
)
p2

plotPDF(plotList = p1, 
    name = "Plot-UMAP-Marker-Genes-RNA-W-IntegratedGEX_MonoRemoved.pdf", 
    ArchRProj = archR, 
    addDOC = FALSE, width = 5, height = 5)

plotPDF(plotList = p2,
    name = "Plot-UMAP-Marker-Genes-Gene-Scores_GeneScore_MonoRemoved.pdf",
    ArchRProj = archR,
    addDOC = FALSE, width = 5, height = 5)
```

##########################################
### CHAPTER 9 - PSEUDO-BULK REPLICATES ###
##########################################

scATAC is binary, meaning any locus is either accessible or not, making some analyses impossible. Furthermore, we need replicates to get statistical significance! In single-cell this is done via pseudo-bulking

ArchR makes pseudo-bulk replicates using a tiered priority approach. The user specifies the min and max replicates, the min and max number of cells per replicate, and the sampling ratio to be used if a particular grouping lacks sufficient cells (for ex, sampling ratio of 0.8 means cells can be sampld without replacement up to 80% of the total number of cells per replicate)

Cell groups to be used are often clusters called by ArchR

Makes X replicates PER grouping (aka cluster in most cases). Default is min 2 reps and 5 max
```{r}
library("BSgenome.Hsapiens.UCSC.hg38")

archR <- addGroupCoverages(ArchRProj = archR, groupBy = "HarmonyClusters2",
                                minRep = 2, maxReplicates = 5, minCells = 40, maxCells = 500, sampleRatio = 0.8)
```

##################################
### CHAPTER 10 - CALLING PEAKS ###
##################################

Peaks are basically regions of the genome with open accessibility.

ArchR opts to use 501bp fixed-width peak ranges as opposed to variable peaks. This means that you don't need to normalize, in part bcuz most peaks are less than 501bp anyway. Furthermore, using variable peaks makes it hard to merge peaks between samples. Overall not worth

ArchR uses an Iterative Overlap approach: this involves ranking the most significant peaks. The most significant peak is retained and any peaks that overlap it are removed. This process is removed until there are no more peaks
```{r}
archR <- addReproduciblePeakSet(
    ArchRProj = archR, 
    groupBy = "HarmonyClusters2"
)

#getPeakSet(archR)
```
Add Peak Matrix
```{r}
archR <- addPeakMatrix(archR)
```
Save it out
```{r}
saveArchRProject(ArchRProj = archR, outputDirectory = "WM_FullSetRerun_PeakMatrixAdded", load = FALSE)
```

################################
### IDENTIFYING MARKER PEAKS ###
################################

```{r}
markersPeaks <- getMarkerFeatures(
    ArchRProj = archR, 
    useMatrix = "PeakMatrix", 
    groupBy = "predictedGroup_Un",
  bias = c("TSSEnrichment", "log10(nFrags)"),
  testMethod = "wilcoxon"
)

markersPeaks

#markerList <- getMarkers(markersPeaks, cutOff = "FDR <= 0.01 & Log2FC >= 1")
markerList <- getMarkers(markersPeaks, cutOff = "FDR <= 0.01 & Log2FC >= 1", returnGR = TRUE)
markerList$`Memory B cells`
```
# Visualize Marker Peaks via heatmap
```{r}
heatmapPeaks <- plotMarkerHeatmap(
  seMarker = markersPeaks, 
  cutOff = "FDR <= 0.1 & Log2FC >= 0.5",
  transpose = TRUE
)

draw(heatmapPeaks, heatmap_legend_side = "bot", annotation_legend_side = "bot")

plotPDF(heatmapPeaks, name = "Peak-Marker-Heatmap", width = 8, height = 6, ArchRProj = archR, addDOC = FALSE)
```
Per cell type
```{r}
pma <- plotMarkers(seMarker = markersPeaks, name = "Memory B cells", cutOff = "FDR <= 0.1 & Log2FC >= 1", plotAs = "Volcano")
pma2 <- plotMarkers(seMarker = markersPeaks, name = "Plasma cells", cutOff = "FDR <= 0.1 & Log2FC >= 1", plotAs = "Volcano")
pma3 <- plotMarkers(seMarker = markersPeaks, name = "Naive B cells", cutOff = "FDR <= 0.1 & Log2FC >= 1", plotAs = "Volcano")

plotPDF(pma, pma2, pma3, name = "MemoryBNaiveB_andPCs-Markers-MA", width = 5, height = 5, ArchRProj = archR, addDOC = FALSE)
```

```{r}
p <- plotBrowserTrack(
    ArchRProj = archR, 
    groupBy = "predictedGroup_Un", 
    geneSymbol = c("MYD88"),
    features =  getMarkers(markersPeaks, cutOff = "FDR <= 0.1 & Log2FC >= 1", returnGR = TRUE)["Plasma cells"],
    upstream = 50000,
    downstream = 50000
)

grid::grid.newpage()
grid::grid.draw(p$)

plotPDF(p, name = "Plot-Tracks-With-Features-MME", width = 5, height = 5, ArchRProj = archR, addDOC = FALSE)
```
# Pairwise test
```{r}
markerTest <- getMarkerFeatures(
  ArchRProj = archR, 
  useMatrix = "PeakMatrix",
  groupBy = "predictedGroup_Un",
  testMethod = "wilcoxon",
  bias = c("TSSEnrichment", "log10(nFrags)"),
  useGroups = "Memory B cells",
  bgdGroups = "Plasma cells"
)

pv <- plotMarkers(seMarker = markerTest, name = "Memory B cells", cutOff = "FDR <= 0.1 & abs(Log2FC) >= 1", plotAs = "Volcano")
pv

plotPDF(pv, name = "MemoryB-PCs_Marker-Volcano", width = 5, height = 5, ArchRProj = archR, addDOC = FALSE)
```
Browser Track Marker Peaks
```{r}
p <- plotBrowserTrack(
    ArchRProj = archR, 
    groupBy = "predictedGroup_Un", 
    geneSymbol = c("CD27"),
    features =  getMarkers(markersPeaks, cutOff = "FDR <= 0.1 & Log2FC >= 1", returnGR = TRUE)["Memory B cell"],
    upstream = 50000,
    downstream = 50000
)

grid::grid.newpage()
grid::grid.draw(p$BCL)

plotPDF(p, name = "Plot-Tracks-With-Features_BCL6", width = 5, height = 5, ArchRProj = archR, addDOC = FALSE)
```

###########################################################
### CHAPTER 12 - MOTIF ENRICHMENT IN DIFFERENTIAL PEAKS ###
###########################################################
```{r}
archR <- addMotifAnnotations(ArchRProj = archR, motifSet = "cisbp", name = "Motif")
```
Enrichment testing using previous test...so memory B vs plasma cells
```{r}
motifsUp <- peakAnnoEnrichment(
    seMarker = markerTest,
    ArchRProj = archR,
    peakAnnotation = "Motif",
    cutOff = "FDR <= 0.1 & Log2FC >= 0.5"
  )
```
Create dataframe with motif names,corrected p-values, and significance rank.
```{r}
df <- data.frame(TF = rownames(motifsUp), mlog10Padj = assay(motifsUp)[,1])
df <- df[order(df$mlog10Padj, decreasing = TRUE),]
df$rank <- seq_len(nrow(df))
head(df)
```
Plot upregulated in Memory Bs
```{r}
ggUp <- ggplot(df, aes(rank, mlog10Padj, color = mlog10Padj)) + 
  geom_point(size = 1) +
  ggrepel::geom_label_repel(
        data = df[rev(seq_len(30)), ], aes(x = rank, y = mlog10Padj, label = TF), 
        size = 1.5,
        nudge_x = 2,
        color = "black"
  ) + theme_ArchR() + 
  ylab("-log10(P-adj) Motif Enrichment") + 
  xlab("Rank Sorted TFs Enriched") +
  scale_color_gradientn(colors = paletteContinuous(set = "comet"))

ggUp
```
Upregulated in plasma cells
```{r}
motifsDo <- peakAnnoEnrichment(
    seMarker = markerTest,
    ArchRProj = archR,
    peakAnnotation = "Motif",
    cutOff = "FDR <= 0.1 & Log2FC <= -0.5"
  )
```
```{r}
df <- data.frame(TF = rownames(motifsDo), mlog10Padj = assay(motifsDo)[,1])
df <- df[order(df$mlog10Padj, decreasing = TRUE),]
df$rank <- seq_len(nrow(df))
head(df)

# So IRF8, 9, 5, 3, POU2F2 and STAT2 are most accessible motifs in plasma cells
```
Show upregulated in plasma cells
```{r}
ggDo <- ggplot(df, aes(rank, mlog10Padj, color = mlog10Padj)) + 
  geom_point(size = 1) +
  ggrepel::geom_label_repel(
        data = df[rev(seq_len(30)), ], aes(x = rank, y = mlog10Padj, label = TF), 
        size = 1.5,
        nudge_x = 2,
        color = "black"
  ) + theme_ArchR() + 
  ylab("-log10(FDR) Motif Enrichment") +
  xlab("Rank Sorted TFs Enriched") +
  scale_color_gradientn(colors = paletteContinuous(set = "comet"))

ggDo
```
Save out figs
```{r}
plotPDF(ggUp, ggDo, name = "Erythroid-vs-Progenitor-Markers-Motifs-Enriched", width = 5, height = 5, ArchRProj = archR, addDOC = FALSE)
```
### MOTIF ENRICHMENT IN MARKER PEAKS ###
```{r}
enrichMotifs <- peakAnnoEnrichment(
    seMarker = markersPeaks,
    ArchRProj = archR,
    peakAnnotation = "Motif",
    cutOff = "FDR <= 0.1 & Log2FC >= 0.5"
  )
```
```{r}
heatmapEM <- plotEnrichHeatmap(enrichMotifs, n = 7, transpose = TRUE)
ComplexHeatmap::draw(heatmapEM, heatmap_legend_side = "bot", annotation_legend_side = "bot")
plotPDF(heatmapEM, name = "Motifs-Enriched-Marker-Heatmap", width = 8, height = 6, ArchRProj = archR, addDOC = FALSE)
```
ENCODE TF binding sites
allows us to compare to database of known TFs
```{r}
archR <- addArchRAnnotations(ArchRProj = archR, collection = "EncodeTFBS")

enrichEncode <- peakAnnoEnrichment(
    seMarker = markersPeaks,
    ArchRProj = archR,
    peakAnnotation = "EncodeTFBS",
    cutOff = "FDR <= 0.1 & Log2FC >= 0.5"
  )

heatmapEncode <- plotEnrichHeatmap(enrichEncode, n = 7, transpose = TRUE)
ComplexHeatmap::draw(heatmapEncode, heatmap_legend_side = "bot", annotation_legend_side = "bot")
plotPDF(heatmapEncode, name = "EncodeTFBS-Enriched-Marker-Heatmap", width = 8, height = 6, ArchRProj = archR, addDOC = FALSE)
```
```{r}
archR <- addArchRAnnotations(ArchRProj = archR, collection = "ATAC")

enrichATAC <- peakAnnoEnrichment(
    seMarker = markersPeaks,
    ArchRProj = archR,
    peakAnnotation = "ATAC",
    cutOff = "FDR <= 0.1 & Log2FC >= 0.5"
  )

heatmapATAC <- plotEnrichHeatmap(enrichATAC, n = 7, transpose = TRUE)
ComplexHeatmap::draw(heatmapATAC, heatmap_legend_side = "bot", annotation_legend_side = "bot")
plotPDF(heatmapATAC, name = "ATAC-Enriched-Marker-Heatmap", width = 8, height = 6, ArchRProj = archR, addDOC = FALSE)
```
### CODEX NOW ###
```{r}
archR <- addArchRAnnotations(ArchRProj = archR, collection = "Codex")

enrichCodex <- peakAnnoEnrichment(
    seMarker = markersPeaks,
    ArchRProj = archR,
    peakAnnotation = "Codex",
    cutOff = "FDR <= 0.1 & Log2FC >= 0.5"
  )

heatmapCodex <- plotEnrichHeatmap(enrichCodex, n = 7, transpose = TRUE)
ComplexHeatmap::draw(heatmapCodex, heatmap_legend_side = "bot", annotation_legend_side = "bot")
plotPDF(heatmapCodex, name = "Codex-Enriched-Marker-Heatmap", width = 8, height = 6, ArchRProj = archR, addDOC = FALSE)

```

### CHROMVAR MOTIF DEVIATIONS ANALYSIS ###
These enrichments, however, are not calculated on a per-cell basis and they do not take into account the insertion sequence bias of the Tn5 transposase. chromVAR, an R packaged from the Greenlead Lab, was created to account for these issues. chromVAR is designed for predicting enrichment of TF activity on a per-cell basis from sparse chromatin accessibility data. The two primary outputs of chromVAR are:

“deviations” - A deviation is a bias-corrected measurement of how far the per-cell accessibility of a given feature (i.e motif) deviates from the expected accessibility based on the average of all cells or samples.
“z-score” - The z-score, also known as a “deviation score” is the z-score for each bias-corrected deviation across all cells. The absolute value of the deviation score is correlated with the per-cell read depth. This is because, with more reads, you have higher confidence that the difference in per-cell accessibility of the given feature (i.e. motif) from the expectation is greater than would occur by chance.

```{r}
if("Motif" %ni% names(archR@peakAnnotation)){
    projHeme5 <- addMotifAnnotations(ArchRProj = archR, motifSet = "cisbp", name = "Motif")
}
archR <- addBgdPeaks(archR)
```
Now this
```{r}
archR <- addDeviationsMatrix(
  ArchRProj = archR, 
  peakAnnotation = "Motif",
  force = TRUE
)

plotVarDev <- getVarDeviations(archR, name = "MotifMatrix", plot = TRUE)

plotPDF(plotVarDev, name = "Variable-Motif-Deviation-Scores", width = 5, height = 5, ArchRProj = archR, addDOC = FALSE)
```
```{r}
motifs <- c("GATA1", "CEBPA", "EBF1", "IRF4", "TBX21", "PAX5")
#motifs <- c("PAX5", "MS4A1", "MUM1", "CD27", "BCL6", "SDC1", "CD38", "CD24", "CD19")

markerMotifs <- getFeatures(archR, select = paste(motifs, collapse="|"), useMatrix = "MotifMatrix")
markerMotifs

markerMotifs <- grep("z:", markerMotifs, value = TRUE)
markerMotifs <- markerMotifs[markerMotifs %ni% "z:SREBF1_22"]
markerMotifs

p <- plotGroups(ArchRProj = archR, 
  groupBy = "predictedGroup_Un", 
  colorBy = "MotifMatrix", 
  name = markerMotifs,
  imputeWeights = getImputeWeights(archR)
)

p2 <- lapply(seq_along(p), function(x){
  if(x != 1){
    p[[x]] + guides(color = FALSE, fill = FALSE) + 
    theme_ArchR(baseSize = 6) +
    theme(plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm")) +
    theme(
        axis.text.y=element_blank(), 
        axis.ticks.y=element_blank(),
        axis.title.y=element_blank()
    ) + ylab("")
  }else{
    p[[x]] + guides(color = FALSE, fill = FALSE) + 
    theme_ArchR(baseSize = 6) +
    theme(plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm")) +
    theme(
        axis.ticks.y=element_blank(),
        axis.title.y=element_blank()
    ) + ylab("")
  }
})
do.call(cowplot::plot_grid, c(list(nrow = 1, rel_widths = c(2, rep(1, length(p2) - 1))),p2))

plotPDF(p, name = "Plot-Groups-Deviations-w-Imputation", width = 5, height = 5, ArchRProj = archR, addDOC = FALSE)
```
```{r}
p <- plotEmbedding(
    ArchRProj = archR, 
    colorBy = "MotifMatrix", 
    name = sort(markerMotifs), 
    embedding = "UMAPHarmony_Samples",
    imputeWeights = getImputeWeights(archR)
)

p2 <- lapply(p, function(x){
    x + guides(color = FALSE, fill = FALSE) + 
    theme_ArchR(baseSize = 6.5) +
    theme(plot.margin = unit(c(0, 0, 0, 0), "cm")) +
    theme(
        axis.text.x=element_blank(), 
        axis.ticks.x=element_blank(), 
        axis.text.y=element_blank(), 
        axis.ticks.y=element_blank()
    )
})
do.call(cowplot::plot_grid, c(list(ncol = 3),p2))

plotPDF(p, name = "Plot-Groups-MotifDeviation_Zscore_UMAPs", width = 5, height = 5, ArchRProj = archR, addDOC = FALSE)

```
```{r}
markerRNA <- getFeatures(archR, select = paste(motifs, collapse="|"), useMatrix = "GeneScoreMatrix")
markerRNA <- markerRNA[markerRNA %ni% c("SREBF1","CEBPA-DT")]
markerRNA

p <- plotEmbedding(
    ArchRProj = archR, 
    colorBy = "GeneScoreMatrix", 
    name = sort(markerRNA), 
    embedding = "UMAPHarmony_Samples",
    imputeWeights = getImputeWeights(archR)
)

p2 <- lapply(p, function(x){
    x + guides(color = FALSE, fill = FALSE) + 
    theme_ArchR(baseSize = 6.5) +
    theme(plot.margin = unit(c(0, 0, 0, 0), "cm")) +
    theme(
        axis.text.x=element_blank(), 
        axis.ticks.x=element_blank(), 
        axis.text.y=element_blank(), 
        axis.ticks.y=element_blank()
    )
})
do.call(cowplot::plot_grid, c(list(ncol = 3),p2))

plotPDF(p, name = "Plot-Groups-Motif_GeneScores_UMAPs", width = 5, height = 5, ArchRProj = archR, addDOC = FALSE)
```
```{r}
markerRNA <- getFeatures(archR, select = paste(motifs, collapse="|"), useMatrix = "GeneIntegrationMatrix")
markerRNA <- markerRNA[markerRNA %ni% c("SREBF1","CEBPA-DT")]
markerRNA

p <- plotEmbedding(
    ArchRProj = archR, 
    colorBy = "GeneIntegrationMatrix", 
    name = sort(markerRNA), 
    embedding = "UMAPHarmony_Samples",
    continuousSet = "blueYellow",
    imputeWeights = getImputeWeights(archR)
)

p2 <- lapply(p, function(x){
    x + guides(color = FALSE, fill = FALSE) + 
    theme_ArchR(baseSize = 6.5) +
    theme(plot.margin = unit(c(0, 0, 0, 0), "cm")) +
    theme(
        axis.text.x=element_blank(), 
        axis.ticks.x=element_blank(), 
        axis.text.y=element_blank(), 
        axis.ticks.y=element_blank()
    )
})
do.call(cowplot::plot_grid, c(list(ncol = 3),p2))

plotPDF(p, name = "Plot-Groups-Motif_GeneExpression_UMAPs", width = 5, height = 5, ArchRProj = archR, addDOC = FALSE)
```

### SKIPPED CUSTOM DEVIATIONS WITH ENCODE CHAPTER 13 ###
### AS WELL AS FOOTPRINTING CHAPTER 14 ### 
### COME BACK AND DO IT LATER ###

##################################
### COACCESSABILITY WITH ARCHR ###
##################################
```{r}
archR <- addCoAccessibility(
    ArchRProj = archR,
    reducedDims = "Harmony_Samples"
)
```
###############################
### SUBSETTING OUT CONTROLS ###
###############################

They aren't helping anything at this point. Also, the annotation of these cells is off because I used the NON-CONTROL RNA object to do integration...so no GC cells identfied, etc. Will fix later
```{r}
full_seurat <- readRDS("/Users/gagled01/morganLab/Waldenstroms/singlecell/scRNA_SCTransformIntegrated_CTAnnotated.rds")

FeaturePlot(full_seurat, features = "FOXA1")
```


---
title: "WM_ArchR_Analysis"
output: html_document
date: "2023-06-27"
---

Load libraries
```{r}
library(ArchR)
library(Seurat)
addArchRThreads(threads = 1)
addArchRGenome("hg38")
options(future.globals.maxSize=100000000000000000) 
```
Load fragments
```{r}
frag_dir <- "/Users/gagled01/morganLab/Waldenstroms/singlecell/data/ATAC_fragments/fragments"
fragments <- list.files(frag_dir)
```
OR load an existing ArchR project
```{r}
archR <- loadArchRProject(path = "/Users/gagled01/morganLab/Waldenstroms/Waldenstroms_Git/WM_NoControls_NoProgens_chromVAR_DownstreamObject")
table(archR$samplesClean)
```
Create arrow files
```{r}
arrow.files <- createArrowFiles(
  inputFiles = fragments,
  sampleNames = as.character(fragments),
  minTSS = 4,
  minFrags = 1000,
  addTileMat = T,
  addGeneScoreMat = T
)
```
# Pre filtering cell counts
```{r}
pre.filt.01_076 <- readRDS("/Users/gagled01/morganLab/Waldenstroms/singlecell/data/ATAC_fragments/QualityControl/01-076_atac_fragments.tsv.gz/01-076_atac_fragments.tsv.gz-Pre-Filter-Metadata.rds")
pre.filt.01_115 <- readRDS("/Users/gagled01/morganLab/Waldenstroms/singlecell/data/ATAC_fragments/QualityControl/01-115_atac_fragments.tsv.gz/01-115_atac_fragments.tsv.gz-Pre-Filter-Metadata.rds")
pre.filt.01_131 <- readRDS("/Users/gagled01/morganLab/Waldenstroms/singlecell/data/ATAC_fragments/QualityControl/01-131_atac_fragments.tsv.gz/01-131_atac_fragments.tsv.gz-Pre-Filter-Metadata.rds")
pre.filt.01_163 <- readRDS("/Users/gagled01/morganLab/Waldenstroms/singlecell/data/ATAC_fragments/QualityControl/01-163_atac_fragments.tsv.gz/01-163_atac_fragments.tsv.gz-Pre-Filter-Metadata.rds")
pre.filt.01_190 <- readRDS("/Users/gagled01/morganLab/Waldenstroms/singlecell/data/ATAC_fragments/QualityControl/01-190_atac_fragments.tsv.gz/01-190_atac_fragments.tsv.gz-Pre-Filter-Metadata.rds")
pre.filt.04_003 <- readRDS("/Users/gagled01/morganLab/Waldenstroms/singlecell/data/ATAC_fragments/QualityControl/04-003_atac_fragments.tsv.gz/04-003_atac_fragments.tsv.gz-Pre-Filter-Metadata.rds")
pre.filt.04_006 <- readRDS("/Users/gagled01/morganLab/Waldenstroms/singlecell/data/ATAC_fragments/QualityControl/04-006_atac_fragments.tsv.gz/04-006_atac_fragments.tsv.gz-Pre-Filter-Metadata.rds")

pre.filt.wm25 <- readRDS("/Users/gagled01/morganLab/Waldenstroms/singlecell/data/ATAC_fragments/QualityControl/WM25_atac_fragments.tsv.gz/WM25_atac_fragments.tsv.gz-Pre-Filter-Metadata.rds")
pre.filt.wm43 <- readRDS("/Users/gagled01/morganLab/Waldenstroms/singlecell/data/ATAC_fragments/QualityControl/WM43_atac_fragments.tsv.gz/WM43_atac_fragments.tsv.gz-Pre-Filter-Metadata.rds")
pre.filt.wm46 <- readRDS("/Users/gagled01/morganLab/Waldenstroms/singlecell/data/ATAC_fragments/QualityControl/WM46_atac_fragments.tsv.gz/WM46_atac_fragments.tsv.gz-Pre-Filter-Metadata.rds")
pre.filt.wm47 <- readRDS("/Users/gagled01/morganLab/Waldenstroms/singlecell/data/ATAC_fragments/QualityControl/WM47_atac_fragments.tsv.gz/WM47_atac_fragments.tsv.gz-Pre-Filter-Metadata.rds")
pre.filt.wm54 <- readRDS("/Users/gagled01/morganLab/Waldenstroms/singlecell/data/ATAC_fragments/QualityControl/WM54_atac_fragments.tsv.gz/WM54_atac_fragments.tsv.gz-Pre-Filter-Metadata.rds")
pre.filt.wm65 <- readRDS("/Users/gagled01/morganLab/Waldenstroms/singlecell/data/ATAC_fragments/QualityControl/WM65_atac_fragments.tsv.gz/WM65_atac_fragments.tsv.gz-Pre-Filter-Metadata.rds")

total.prefilt.cells <- sum(length(pre.filt.01_076$cellNames),
                           length(pre.filt.01_115$cellNames),
                           length(pre.filt.01_131$cellNames),
                           length(pre.filt.01_163$cellNames),
                           length(pre.filt.01_190$cellNames),
                           length(pre.filt.04_003$cellNames),
                           length(pre.filt.04_006$cellNames),
                           length(pre.filt.wm25$cellNames),
                           length(pre.filt.wm43$cellNames),
                           length(pre.filt.wm46$cellNames),
                           length(pre.filt.wm47$cellNames),
                           length(pre.filt.wm54$cellNames),
                           length(pre.filt.wm65$cellNames))
total.prefilt.cells
```
# Doublet inference
# Doublets are inevitable in single cell data. The % of doublets is proportional to the number of cells loaded into the experiment. 
# Doublets are especially problematic in the context of developmental/trajectory data because doublets can look like a mixture between 2 cell types which can be confounded with intermediate cell states. THIS WM DATA IS B CELL LINEAGE...SO TRAJECTORY!!! 
# To predict doublets, ArchR mixes the reads from large combos of cells to create synthetic doublets and projects them into a UMAP. Iterating this process 1000x times allows identification of cells in the REAL data which look like synthetic doublets.
# We want to see R values greater than 0.9, which implies that the cells within each synthetic UMAP have significant heterogeneity, which we want.
# In the output plots, use the doublet enrichment plot 
```{r}
dub.scores <- addDoubletScores(
  input = arrow.files,
  k = 10,
  knnMethod = "UMAP",
  LSIMethod = 1
) 
```
Create ArchR Project
```{r}
archR <- ArchRProject(
  ArrowFiles = arrow.files,
  outputDirectory = "WM_BothRuns",
  copyArrows = T
)
```
# Clean up sample names and add metadata
```{r}
clean.cellnames <- gsub("atac_fragments.tsv.gz#", "", archR$cellNames)
archR$cellNames_clean <- clean.cellnames

# Iteratively clean up sample names
clean.samplenames <- gsub("_atac_fragments.tsv.gz", "", archR$Sample)
archR$samplesClean <- clean.samplenames
clean.samplenames2 <- gsub("_fragments.tsv.bgz", "", archR$samplesClean)
archR$samplesClean <- clean.samplenames2
clean.samplenames3 <- gsub("_fragments.tsv.gz", "", archR$samplesClean)
archR$samplesClean <- clean.samplenames3
clean.samplenames4 <- gsub("GSM........", "", archR$samplesClean)
archR$samplesClean <- clean.samplenames4
clean.samplenames5 <- gsub("tonsil_1.", "stanford_1", archR$samplesClean)
archR$samplesClean <- clean.samplenames5
clean.samplenames6 <- gsub("tonsil_2.", "stanford_2", archR$samplesClean)
archR$samplesClean <- clean.samplenames6
clean.samplenames7 <- gsub("tonsil_3.", "stanford_3", archR$samplesClean)
archR$samplesClean <- clean.samplenames7

# Assign info about data source
sources <- gsub("stanford_.", "Stanford", archR$samplesClean)
archR$source <- sources
sources2 <- gsub("BCP00.", "QMUL", archR$source)
archR$source <- sources2
sources3 <- gsub("0.-...", "NYU", archR$source)
archR$source <- sources3
case.control4 <- gsub("WM..", "NYU", archR$source)
archR$source <- case.control4

# And case/control data
case.control <- gsub("0.-...", "WM", archR$samplesClean)
archR$case.control <- case.control
case.control2 <- gsub("BCP00.", "Healthy", archR$case.control)
archR$case.control <- case.control2
case.control3 <- gsub("stanford_.", "Healthy", archR$case.control)
archR$case.control <- case.control3
case.control4 <- gsub("WM..", "WM", archR$case.control)
archR$case.control <- case.control4

# Mutation status
archR$myd88 <- archR$source
myd88.1 <- gsub("NYU", "+", archR$source)
archR$myd88 <- myd88.1
myd88.2 <- gsub("QMUL", "-", archR$myd88)
archR$myd88 <- myd88.2
myd88.3 <- gsub("Stanford", "-", archR$myd88)
archR$myd88 <- myd88.3
table(archR$myd88)

# CXCR4
archR$cxcr4 <- archR$samplesClean
cxcr4.1 <- gsub("01-190", "+", archR$cxcr4)
archR$cxcr4 <- cxcr4.1
cxcr4.2 <- gsub("04-003", "+", archR$cxcr4)
archR$cxcr4 <- cxcr4.2
cxcr4.3 <- gsub("01-...", "-", archR$cxcr4)
archR$cxcr4 <- cxcr4.3
cxcr4.4 <- gsub("04-...", "-", archR$cxcr4)
archR$cxcr4 <- cxcr4.4
cxcr4.5 <- gsub("BCP00.", "-", archR$cxcr4)
archR$cxcr4 <- cxcr4.5
cxcr4.6 <- gsub("stanford_.", "-", archR$cxcr4)
archR$cxcr4 <- cxcr4.6
table(archR$cxcr4)  
```
# They have found that the best metrics for QC are the TSS enrichment score and the number of unique frags
# Note that in creating the arrow files we have already set minimum values for both the TSS (n = 4) and n frags (n = 1000)
# But let's still plot it up to see what remains
```{r}
qc.df <- getCellColData(archR, select = c("log10(nFrags)", "TSSEnrichment"))

p <- ggPoint(
  x = qc.df[,1],
  y = qc.df[,2],
  colorDensity = T,
  continuousSet = "sambaNight",
  xlabel = "Log10 Unique Fragments",
  ylabel = "TSS Enrichment",
  xlim = c(log10(500), quantile(qc.df[,1], probs = 0.99)),
  ylim = c(0, quantile(qc.df[,2], probs = 0.99))
) + geom_hline(yintercept = 4, lyt = "dashed") + geom_vline(xintercept = 3, lyt = "dashed")

p

plotPDF(p, name = "TSS-vs-Frags_BothSets.pdf", ArchRProj = archR, addDOC = F) # save it out
```
# Make ridge and violin plots of TSS enrichment
```{r}
ridge <- plotGroups(
  ArchRProj = archR,
  groupBy = "samplesClean",
  colorBy = "cellColData",
  name = "TSSEnrichment",
  plotAs = "ridges"
)

violin <- plotGroups(
  ArchRProj = archR,
  groupBy = "samplesClean",
  colorBy = "cellColData",
  name = "TSSEnrichment",
  alpha = 0.4,
  plotAs = "violin"
)

ridge
violin
plotPDF(ridge, violin, name = "TSS_Ridge_Violin.pdf", ArchRProj = archR, addDOC = F, width = 5, height = 5)

```
# Make ridge plot of unique frags
```{r}
p3 <- plotGroups(
    ArchRProj = archR, 
    groupBy = "samplesClean", 
    colorBy = "cellColData", 
    name = "log10(nFrags)",
    plotAs = "ridges"
   )

plotPDF(p3, name = "QC-Sample-FragSizes-Ridges.pdf", ArchRProj = archR, addDOC = F, width = 5, height = 5)
```
# Plot fragment size distribution and TSS enrichment by sample
# The TSS enrichment plot should show a clear peak in the center and a small peak to eh right caused by the well-positioned +1 nucleosome
```{r}
p1 <- plotFragmentSizes(ArchRProj = archR)

p2 <- plotTSSEnrichment(ArchRProj = archR)

p1
p2

plotPDF(p1, p2, name = "QC-Sample-FragSizes-TSSProfile_BothSets.pdf", ArchRProj = archR, addDOC = F, width = 5, height = 5)
```
# Subsetting out cells with low TSS in samples 01-190 and 04-003
```{r}
idsRemove <- as.character(archR$cellNames[(archR$samplesClean %in% c("01-190", "04-003") & archR$TSSEnrichment < 8)])
archR <- archR[!archR$cellNames %in% idsRemove,]

ridge2 <- plotGroups(
  ArchRProj = archR,
  groupBy = "Sample",
  colorBy = "cellColData",
  name = "TSSEnrichment",
  plotAs = "ridges"
)

plotPDF(ridge2, name = "TSS_Ridge_Violin_BelowTSS10_Removed.pdf", ArchRProj = archR, addDOC = F, width = 5, height = 5)

ridge2
```
# Filtering out doubletes...default ratio is 1
```{r}
archR <- filterDoublets(archR, filterRatio = 1)
```
# Save project out
# This copies a new set of arrow files and a new ArchRProj to the output dir
# Unless you specify load = F, this existing project in this R studio will still be the ORIGINAL arrow files
```{r}
saveArchRProject(ArchRProj = archR, outputDirectory = "WM_BothSets", load = T)
```
# Filtering doublets
# This filters based on a ratio which allows you to apply a consistent filter across different samples with different % of doublets

############################################
### CHAPTER 4 - DIMENSIONALITY REDUCTION ###
############################################

# Dimensionality reduction with scATAC-seq data is tough due to data sparsity. A particular site is either accessible on one allele, both, or neither.
# It ends up that many loci have 0 accessible alleles. As such, you'd be reluctant to say that a cell with 3 insertions in a given site is actually 3x more accessible than another cell with only 1 insertion in the same site. 
# Many analytical strategies then binarizes their ATAC data matrix to 1s and 0s, which is mostly 0s. But this is still difficult because 0 can mean both non-accessible and not-sampled and these are different things biologically.
# If you would perform a standard dimensionality reduction like PCA, the first PC would just be all of the 0 positions
# This is gotten around via a layered dimensionality reduction approach
# First, we use a Latent Semantic Indexing (LSI) which is borrowed from natural language processing
# This calculates the peak frequency per cell, normalized by depth.
# These values are then normalized by the inverse document frequency which weighs features by how often they occur, identifying features that are more specific rather than commonly accessible
# The resultant term frequency-inverse document frequency (TF-IDF) matrix reflects how important a region/peak is to a sample.
# Then, through a technique called singular value decomposition (SVD), the most valuable information across samples is identified and represented in a lower dimensional space. Dam
# Finally, a more conventional dimensionality reduction technique like UMAP can be used to visualize the data

# ArchR offers a few different LSI implementations but by default uses the method introduced in Signac (!), which uses a term frequency that has been depth normalized to 10,000 and again normalized with the log(tf-idf)
# It is suggested to use genome-wide tiles as the inputs to LSI dimensionality reduction, but these can become prohibitively large. ArchR can do this more rapidly using 500bp tiles...but also offers an "estimated LSI" approach which only uses a subset of total cells, thereby speeding up the process and decreasing granularity of the data, which may end up reducing batch effects in the data

#### Iterative Latent Semantic Indexing (LSI) ####
# This approach computes an initial LSI transformation on the most accessible tiles and then another on the top variable features from the first iteration. You can repeat this more if necessary
# LSI is NOT deterministic...so you will not get exactly the same results. So make sure to save the ArchRProject once you have an ideal dimensionality reduction
```{r}
archR <- addIterativeLSI(
  ArchRProj = archR,
  useMatrix = "TileMatrix",
  name = "IterativeLSI",
  iterations = 2,
  clusterParams = list( # based on Seurat's FindClusters()
    resolution = c(0.25),
    sampleCells = 2000,
    n.start = 10
  ),
  varFeatures = 20000,
  dimsToUse = 1:20,
  force = T
)
```
# You can also explicitly correct for batch effect with Harmony
# See documentation for this. Won't do now because only 1 sample lol
####################################
### BATCH CORRECTION VIA HARMONY ###
####################################
```{r}
# adding batch for full dataset integration

archR$batch <- archR$source
archR$batch[archR$samplesClean %in% c("01-190", "04-003")] <- "NYU-1"
archR$batch[archR$samplesClean %in% c("01-076", "01-115", "01-131", "01-163", "04-006")] <- "NYU-2"
archR$batch[archR$samplesClean %in% c("WM25", "WM43", "WM46", "WM47", "WM54", "WM65")] <- "NYU-3"

archR <- addHarmony(
    ArchRProj = archR,
    reducedDims = "IterativeLSI",
    name = "Harmony_Source",
    groupBy = "source",
    force = T
)

archR <- addHarmony(
    ArchRProj = archR,
    reducedDims = "IterativeLSI",
    name = "Harmony_Batch",
    groupBy = "batch",
    force = T
)
```
Clustering
# ArchR basically just uses Seurat's FindClusters()
```{r}
archR <- addClusters(
  input = archR,
  reducedDims = "IterativeLSI",
  method = "Seurat",
  name = "Clusters",
  resolution = 0.8,
  force = TRUE
)

archR <- addClusters(
  input = archR,
  reducedDims = "Harmony_Batch",
  method = "Seurat",
  name = "Harmony_Batch_Clusters",
  resolution = 0.8,
  force = TRUE
)

archR <- addClusters(
  input = archR,
  reducedDims = "Harmony_Source",
  method = "Seurat",
  name = "Harmony_Source_Clusters",
  resolution = 0.8,
  force = TRUE
)
```
Embed UMAP
```{r}
archR <- addUMAP(
  ArchRProj = archR,
  reducedDims = "IterativeLSI",
  name = "UMAP",
  nNeighbors = 30,
  minDist = 0.5,
  metric = "cosine",
  force = T
)

archR <- addUMAP(
    ArchRProj = archR, 
    reducedDims = "Harmony_Source", 
    name = "UMAP_Harmony_Source", 
    nNeighbors = 30, 
    minDist = 0.5, 
    metric = "cosine",
    force = T
)

archR <- addUMAP(
    ArchRProj = archR, 
    reducedDims = "Harmony_Batch", 
    name = "UMAP_Harmony_Batch", 
    nNeighbors = 30, 
    minDist = 0.5, 
    metric = "cosine",
    force = T
)

p1 <- plotEmbedding(ArchRProj = archR, colorBy = "cellColData", name = "samplesClean", embedding = "UMAP") #+ 
p2 <- plotEmbedding(ArchRProj = archR, colorBy = "cellColData", name = "samplesClean", embedding = "UMAP_Harmony_Batch")
p3 <- plotEmbedding(ArchRProj = archR, colorBy = "cellColData", name = "samplesClean", embedding = "UMAP_Harmony_Batch_PostSubbing")
p1
p2
p3
plotPDF(p1, p2, p3, name = "WMFullSetControls_Cleaned_Plot-UMAP-Clusters_BatchCorrectionComparison.pdf", ArchRProj = archR, addDOC = FALSE, width = 5, height = 5)
```
Saving it out
```{r}
saveArchRProject(ArchRProj = archR, outputDirectory = "WM_BothSets_Controls_Unintegrated", load = F)
```
# Fix metadata real quick
```{r}
table(archR$predictedGroup_Un)

archR$celltypes_tempFix <- archR$celltypes
archR$celltypes_tempFix[archR$celltypes == "Malignant MBC"] <- "Memory B cells"
archR$celltypes_tempFix[archR$celltypes == "Normal MBC"] <- "Memory B cells"

plotEmbedding(ArchRProj = archR, colorBy = "cellColData", name = "celltypes_tempFix", embedding = "NoProgen_Recluster_UMAP")

archR$celltypes_fix2 <- archR$celltypes
archR$celltypes_fix2[archR$celltypes == "Malignant MBC"] <- "Major MBC"
archR$celltypes_fix2[archR$celltypes == "Normal MBC"] <- "Minor MBC"

plotEmbedding(ArchRProj = archR, colorBy = "cellColData", name = "celltypes_fix2", embedding = "NoProgen_Recluster_UMAP")
```
# UMAPs highlighted by Dataset
```{r}
nyu_cells <- archR$cellNames[archR$batch %in% c("NYU-1", "NYU-2")]
qmul_cells <- archR$cellNames[archR$batch %in% c("QMUL")]
stanford_cells <- archR$cellNames[archR$batch %in% c("Stanford")]


p1 <- plotEmbedding(ArchRProj = archR, colorBy = "cellColData", name = "samplesClean", embedding = "UMAPHarmony_Batch", highlightCells = nyu_cells)
p2 <- plotEmbedding(ArchRProj = archR, colorBy = "cellColData", name = "samplesClean", embedding = "UMAPHarmony_Batch", highlightCells = qmul_cells)
p3 <- plotEmbedding(ArchRProj = archR, colorBy = "cellColData", name = "samplesClean", embedding = "UMAPHarmony_Batch", highlightCells = stanford_cells)

plotPDF(p1,p2,p3, name = "WMFullSet_Cleaned_Plot-UMAP-by-Batch.pdf", ArchRProj = archR, addDOC = FALSE, width = 5, height = 5)

```

################################################
### CHAPTER 7 - GENE SCORES AND MARKER GENES ###
################################################

# Seems like ATAC annotation is basically manual...
# Estimate gene expression based on chromatin accessibility data using gene scores
# The default gene score model in ArchR which considers the accessibility of the entire gene (not just part?), accounts for the activity of putative distal regulatory elements,  
# and considers imposed gene boundaries which minimize the contributed of unrelated regulatory elements. So it tries to emphasize the right distal elements and minimize the wrong

# GENE SCORE - PREDICTION OF GENE EXPRESSION BASED ON ACCESSIBLIITY! 
# BUT WE HAVE ACTUAL EXPRESSION DATA!!! HOW TO CONNECT?

# Does this by creating a tile matrix (default 500bp), overlapping the tiles by some window (default 100kb on either side of the gene?), and computes distance from tile to the gene body. Best predictor of gene expression is local accessibility of the gene region which includes both the promoter and gene body. To identify distal promoters, they subset out tiles that are within the gene window (so 100kb on either side) but do not cross another gene region. They also weigh smaller genes more because large genes can otherwise bias gene scores. So the distance from each tile to the nearby gene is converted to a weight, that weight is again weighted by inverse of gene size. These weights are then multiplied by the number of Tn5 insertions within each tile and summed across all tiles within the gene window. This is the gene score. The gene score is then depth normalized across all genes (default 10000). Dam what the hell lmao.

# Identification of marker features per cluster (this can include peaks, genes, or transcription factor motifs). Can use any matrix as input, including TileMatrix and PeakMatrix, at least. I wonder if GEX?
# Going to skip technical details for now...
```{r}
gs.markers <- getMarkerFeatures(
  ArchRProj = archR,
  useMatrix = "GeneScoreMatrix",
  groupBy = "Clusters",
  bias = c("TSSEnrichment", "log10(nFrags)"), # normalizing based on these metrics?
  testMethod = "wilcoxon"
)

markerList <- getMarkers(gs.markers, cutOff = "FDR <= 0.01 & Log2FC >= 1.25")
head(markerList$C5, n = 10)
```
# Visualize via heatmap
```{r}
#marker.genes <- c("PAX5", "MS4A1", "EBF1", "BCL6", "MME", "CD79A", "CR2", "CD27", "CD74", "HLA-DRA", "RACK1", "IGKC", "JCHAIN", "MZB1", "XBP1")
markerGenes <- c("PAX5", "MS4A1", "MUM1", "CD27", "BCL6", "SDC1", "CD38", "CD24", "CD19")

heatmapGS <- plotMarkerHeatmap(
  seMarker = gs.markers,
  cutOff = "FDR <= 0.01 & Log2FC >= 1.25",
  labelMarkers = markerGenes,
  transpose = T
)

ComplexHeatmap::draw(heatmapGS, heatmap_legend_side = "bot", annotation_legend_side = "bot")

plotPDF(heatmapGS, name = "GeneScores-Marker-Heatmap", width = 8, height = 6, ArchRProj = archR, addDOC = FALSE)
```
# Marker gene inputation with MAGIC to improve UMAPs
```{r}
archR <- addImputeWeights(archR)

markerGenes <- c("PAX5", "MS4A1", "MUM1", "CD27", "BCL6", "SDC1", "CD38", "CD24", "CD19")

p <- plotEmbedding(
    ArchRProj = archR, 
    colorBy = "GeneScoreMatrix", 
    name = markerGenes, 
    embedding = "UMAP",
    imputeWeights = getImputeWeights(archR)
)

p$PAX5
p$BCL6
p$MUM1
p$MS4A1 # MS4A1 = CD20
p$CD27
p$SDC1 # SDC1 = CD138
p$CD38

p2 <- lapply(p, function(x){
    x + guides(color = FALSE, fill = FALSE) + 
    theme_ArchR(baseSize = 6.5) +
    theme(plot.margin = unit(c(0, 0, 0, 0), "cm")) +
    theme(
        axis.text.x=element_blank(), 
        axis.ticks.x=element_blank(), 
        axis.text.y=element_blank(), 
        axis.ticks.y=element_blank()
    )
})
do.call(cowplot::plot_grid, c(list(ncol = 2),p))

p2
plotPDF(plotList = p2, 
    name = "Plot-UMAP-Marker-Genes-W-Imputation_noBC.pdf", 
    ArchRProj = archR, 
    addDOC = FALSE, width = 5, height = 5)
```
######################## KEY FIGURE ALERT!!!? ###########################
### Plotting Tracks of local chromatin accessibilty for marker genes ###
########################################################################
```{r}
p <- plotBrowserTrack(
    ArchRProj = archR, 
    groupBy = "Clusters", 
    geneSymbol = markerGenes, 
    upstream = 50000,
    downstream = 50000
)

plotPDF(plotList = p, 
    name = "Plot-Tracks-Marker-Genes.pdf", 
    ArchRProj = archR, 
    addDOC = FALSE, width = 5, height = 5)
```
##########################################
### CHAPTER 8 - ALIGNING TO SCRNA DATA ###
##########################################

Aligns ATAC gene score matrix to scRNA GEX matrix. Basically just finds the scRNA cell that looks most similar to each scATAC cell.
ArchR accepts Seurat objects
# Load in Seurat object
```{r}
seurat <- readRDS("/Users/gagled01/morganLab/Waldenstroms/singlecell/data/objects/scRNA_WM_NoControls_SCTransformIntegrated_CTAnnotated_Filtered.rds")
```
# This is an Unconstrained Integration method
```{r}
archR <- addGeneIntegrationMatrix(
  ArchRProj = archR,
  useMatrix = "GeneScoreMatrix",
  matrixName = "GeneIntegrationMatrix",
  reducedDims = "Harmony_Batch",
  seRNA = seurat,
  addToArrow = FALSE,
  groupRNA = "majority_voting",
  nameCell = "predictedCell_Un",
  nameGroup = "predictedGroup_Un",
  nameScore = "predictedScore_Un"
)

pal <- paletteDiscrete(values = seurat@meta.data$majority_voting)

p1 <- plotEmbedding(
    archR, 
    colorBy = "cellColData", 
    name = "predictedGroup_Un", 
    pal = pal
)

p2 <- plotEmbedding(
    archR, 
    colorBy = "cellColData", 
    name = "samplesClean"
)

plotPDF(p1, p2, name = "WM_BothSetsNoControls_SCTransform-Integrated_CellTypistAnnotated_UnConstrainedIntegrationUMAPs.pdf", ArchRProj = archR, addDOC = FALSE, width = 5, height = 5)
```
# And this is the constrained integration method, which depends on the output of the unconstrained. In our case, I don't think we need this...but we can pretend we're only interested in Plasma cells and memory B cells. and Naive, for good measure.
```{r}
cM <- as.matrix(confusionMatrix(archR$Clusters, archR$predictedGroup_Un))
preClust <- colnames(cM)[apply(cM, 1 , which.max)]
cbind(preClust, rownames(cM)) #Assignments

unique(unique(archR$predictedGroup_Un))

# selecting clusters that were assigned memory B or PC
cTNK <- paste0(c("Memory B cells", "Plasma cells"), collapse="|")

# and the rest
cNonTNK <- paste0(c("Age-associated B cells", "Germinal center B cells", "Large pre-B cells", "Naive B cells",
                    "Pro-B cells", "Proliferative germinal center B cells", "Small pre-B cells"), collapse="|")
#cNonTNK <- paste0(c("Large pre-B cells", "Naive B cells",
#                    "Pro-B cells", "Small pre-B cells"), collapse="|")
cNonTNK

#Assign scATAC to these categories
clustTNK <- rownames(cM)[grep(cTNK, preClust)]
clustTNK

clustNonTNK <- rownames(cM)[grep(cNonTNK, preClust)]
clustNonTNK

# get cells in these categories
rnaTNK <- colnames(seurat)[grep(cTNK, seurat@meta.data$majority_voting)]

rnaNonTNK <- colnames(seurat)[grep(cNonTNK, seurat@meta.data$majority_voting)]

groupList <- SimpleList(
    TNK = SimpleList(
        ATAC = archR$cellNames[archR$Clusters %in% clustTNK],
        RNA = rnaTNK
    ),
    NonTNK = SimpleList(
        ATAC = archR$cellNames[archR$Clusters %in% clustNonTNK],
        RNA = rnaNonTNK
    )    
)

#~5 minutes
archR <- addGeneIntegrationMatrix(
    ArchRProj = archR, 
    useMatrix = "GeneScoreMatrix",
    matrixName = "GeneIntegrationMatrix",
    reducedDims = "Harmony_Batch",
    seRNA = seurat,
    addToArrow = TRUE, 
    groupList = groupList,
    groupRNA = "majority_voting",
    nameCell = "predictedCell_Co",
    nameGroup = "predictedGroup_Co",
    nameScore = "predictedScore_Co",
    force = TRUE
)


p1 <- plotEmbedding(
    archR, 
    colorBy = "cellColData", 
    name = "predictedGroup_Co",
    embedding = "UMAP_Harmony_Batch"
)
p1

p2 <- plotEmbedding(
    archR, 
    colorBy = "cellColData", 
    name = "samplesClean",
    embedding = "UMAP_Harmony_Batch"
)

plotPDF(p1,p2, name = "WM_BothSetsNoControls_SCTransform_CellTypistAnnotated_ConstrainedIntegrationUMAPs.pdf", ArchRProj = archR, addDOC = FALSE, width = 5, height = 5)
```

# Plotting UMAPs overlayed with the  gene expression values from our integrated matrix
```{r}
#archR <- addImputeWeights(archR)

#markerGenes <- c("PAX5", "MS4A1", "CD27", "BCL6", "SDC1", "CD38", "CD24", "CD19")
markerGenes <- c("PELI1", "MSI2", "IFNG-AS1", "ETV6", "EIF2AK3", "ZNF804A", "PMAIP1", "SYNE2", "PTPRG")
markerGenes <- c("IRF4", "PRDM1", "XBP1", "JCHAIN", "SDC1")
#markerGenes <- c("CD19", "MS4A1", "MME", "CD5", "CD45", "CD23", "CD38", "CD25", "CD11c", "CD103")
markerGenes <- c("CD19", "MS4A1", "MME", "CD5", "PTPRC", "FCER2", "CD38", "IL2RA", "ITGAX", "ITGAE")
markerGenes <- c("CD27", "CR2", "MS4A1", "BCL2", "HHEX", "TLE3", "CD74", "BACH2")
markerGenes <- c("BATF", "PAX5", "BCL6", "TCF3", "IRF8", "IRF4", "POU2AF1", "CD40")
# Treon 2014 paper on SPIB and plasma cell differentiation in WM
#markerGenes <- c("SPIB", "POU2F1", "POU2F2", "XBP1", "IRF4", "PRDM1", "ID2", "BCL6", "PAX5", "SP1", "SP3", "EGR1")

p1 <- plotEmbedding(
    ArchRProj = archR, 
    colorBy = "GeneIntegrationMatrix", 
    name = markerGenes, 
    continuousSet = "solarExtra",
    embedding = "NoProgen_Recluster_UMAP",
    imputeWeights = getImputeWeights(archR)
)
p1

#Same plots but overlain with gene scores
p2 <- plotEmbedding(
    ArchRProj = archR,
    colorBy = "GeneScoreMatrix",
    continuousSet = "horizonExtra",
    name = markerGenes,
    embedding = "NoProgen_Recluster_UMAP",
    imputeWeights = getImputeWeights(archR)
)
p1
p2

plotPDF(plotList = p1, p2, 
    name = "Plot-UMAP-Marker-Genes-RNA-W-Imputation_Integrated_GEX_GeneScores.pdf", 
    ArchRProj = archR, 
    addDOC = FALSE, width = 5, height = 5)

# Get MBC markers
markers.gex <- getMarkerFeatures(
    ArchRProj = archR, 
    useMatrix = "GeneIntegrationMatrix", 
    groupBy = "celltypes",
    bias = c("TSSEnrichment", "log10(nFrags)"),
    testMethod = "wilcoxon"
)

markerList <- getMarkers(markers.gex, cutOff = "FDR <= 0.01 & Log2FC >= 0.5")
df <- data.frame(markerList$`Malignant MBC`)
head(df[order(-df$MeanDiff),], n = 20)
```
# Adding metadata
```{r}
archR$hasPC <- archR$samplesClean
pc.1 <- gsub("01-131", "+", archR$hasPC)
archR$hasPC <- pc.1
pc.2 <- gsub("01-190", "+", archR$hasPC)
archR$hasPC <- pc.2
pc.3 <- gsub("04-003", "+", archR$hasPC)
archR$hasPC <- pc.3
pc.4<- gsub("01-...", "-", archR$hasPC)
archR$hasPC <- pc.4
pc.5 <- gsub("04-...", "-", archR$hasPC)
archR$hasPC <- pc.5
pc.6 <- gsub("BCP00.", "-", archR$hasPC)
archR$hasPC <- pc.6
pc.7 <- gsub("stanford_.", "-", archR$hasPC)
archR$hasPC <- pc.7
table(archR$hasPC)

archR$cxcr4 <- archR$samplesClean
cxcr4.1 <- gsub("01-190", "+", archR$cxcr4)
archR$cxcr4 <- cxcr4.1
cxcr4.2 <- gsub("04-003", "+", archR$cxcr4)
archR$cxcr4 <- cxcr4.2
cxcr4.3 <- gsub("01-...", "-", archR$cxcr4)
archR$cxcr4 <- cxcr4.3
cxcr4.4 <- gsub("04-...", "-", archR$cxcr4)
archR$cxcr4 <- cxcr4.4
cxcr4.5 <- gsub("BCP00.", "-", archR$cxcr4)
archR$cxcr4 <- cxcr4.5
cxcr4.6 <- gsub("stanford_.", "-", archR$cxcr4)
archR$cxcr4 <- cxcr4.6
table(archR$cxcr4)  
```
# Subset out only NYU samples after adding metadata for downstream analysis
```{r}
idxSample <- BiocGenerics::which(archR$samplesClean %in% c("01-076", "01-115", "01-131", "01-163", "01_190",
                                                           "04-003", "04-006",
                                                           "WM25", "WM43", "WM46", "WM47", "WM54", "WM65"))
cellsSample <- archR$cellNames_clean[idxSample]
archR_noControls <- archR[archR$cellNames_clean %in% cellsSample,]

# Recluster and whatnot

saveArchRProject(ArchRProj = archR_noControls, outputDirectory = "WM_BothSets_noControls_SCTransformed_FullIntegated_Nov23", load = F)
```
# Save out
```{r}
saveArchRProject(ArchRProj = archR, outputDirectory = "WM_BothSets_NoControls_FullIntegration_Nov23", load = F)
```
# Just MBC and PCs
```{r}
allpatient_df <- rbind(p01.076_relabun, p01.115_relabun, p01.131_relabun, p01.163_relabun, p01.190_relabun, p04.003_relabun, p04.006_relabun)

allpatient_df$Celltype <- factor(allpatient_df$Celltype, levels = c("Plasma cells", "Memory B cells"))
# Stacked
ggplot(allpatient_df, aes(fill=Celltype, y=Freq, x=Patient)) + 
    geom_bar(position="stack", stat="identity") + 
  xlab(label = "Patient") + ylab("Relative Abundance") + theme_minimal() + 
  theme(axis.text.x = element_text(size = "10", angle = 45, vjust = 0.5, hjust = 0.5))
ggsave("/Users/gagled01/morganLab/Waldenstroms/singlecell/WM_PatientsOnly_CellTypistAnnotated_PC_MBC_Only_StackedBarPlot.png", width = 12, height = 8)
```



